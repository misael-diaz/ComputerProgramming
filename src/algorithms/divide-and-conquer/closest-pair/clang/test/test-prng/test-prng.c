/*
 * Closest Pair Lab						February 23, 2023
 *
 * source: test-prng.c
 * author: @misael-diaz
 *
 * Synopsis:
 * Performs a frequency analysis to test if the Pseudo Random Number Generator PRNG yields
 * uniformly distributed pseudo-random numbers.
 *
 * Copyright (c) 2023 Misael Diaz-Maldonado
 * This file is released under the GNU General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * References:
 * [0] A Koenig and B Moo, Accelerated C++ Practical Programming by Example.
 * [1] JJ McConnell, Analysis of Algorithms, 2nd edition
 *
 */


#include <math.h>				// for floor()
#include <stdio.h>				// for printf() and fprintf()
#include <stdlib.h>				// for NULL
#include "../../include/ds/prng.h"		// includes the PRNG data structure
#include "../../include/util/prng/prng.h"	// includes the PRNG namespace


#define LIMIT 1024
#define SIZE (LIMIT * LIMIT)


extern util_prng_namespace const prng;


void testFrequency ();


int main ()
{
	testFrequency();
	return 0;
}


void testFrequency ()
// exports the frequency data to a plain text file (for post-processing with Python)
{
	Random* r = prng.create();

	if (r == NULL)
	{
		printf("test-frequency: memory allocation error\n");
		return;
	}


	int* part = (int*) malloc ( sizeof(int) * SIZE );

	if (part == NULL)
	{
		r = prng.destroy(r);
		r = NULL;

		printf("test-frequency: memory allocation error\n");
		return;
	}


	double* rands = (double*) malloc( sizeof(double) * SIZE );

	if (rands == NULL)
	{
		r = prng.destroy(r);
		free(part);

		r = NULL;
		part = NULL;

		printf("test-frequency: memory allocation error\n");
		return;
	}


	const int size = SIZE;
	for (int i = 0; i != size; ++i)
	// initializes partition array:
	{
		part[i] = -1;
	}


	// defines the lower and upper bounds [x_min, x_max) for the pseudo-random numbers
	const double limit = LIMIT;
	const double x_min = 0, x_max = limit;


	for (int i = 0; i != size; ++i)
	// initializes `rands' array with pseudo-random numbers in [x_min, x_max):
	{
		double rand = r -> next(r);
		rands[i] = floor(x_min + (x_max - x_min) * rand);
	}


	// frequency analysis:


	for (int i = 0; i != (size - 1); ++i)
	// uses brute force to find repetitions of the `i'-th pseudo-random number:
	{
		if (part[i] < 0)				// if `i' is not repeated
		{
			for (int j = (i + 1); j != size; ++j)	// looks for repetitions
			{
				if (rands[j] == rands[i])	// if `j' is a copy of `i'
				{
					part[j] = i;		// marks j as a copy of i
					--part[i];		// increments copy counter
				}
			}
		}
	}


	FILE* file = fopen("data/frequency.dat", "w");

	if (file == NULL)
	{
		r = prng.destroy(r);
		free(part);
		free(rands);

		r = NULL;
		part = NULL;
		rands = NULL;

		printf("test-frequency: IO ERROR\n");
		return;
	}


	for (int i = 0; i != size; ++i)
	// writes the frequency of the `i'-th pseudo-random number to the datafile:
	{
		if (part[i] < 0)
		{
			int count = (-part[i]);
			double rand = rands[i];
			char format [] = ("%+.15e %d\n");
			fprintf(file, format, rand, count);
		}
	}


	double area = 0;
	double binWidth = 1;
	double numBins = size;
	for (int i = 0; i != size; ++i)
	// calculates the area of the bins (of the histogram):
	{
		if (part[i] < 0)
		{
			double binHeight = (-part[i]);
			area += (binWidth * binHeight);
		}
	}

	// TEST:
	// Yields an average bin-height `avgBinHeight' close to 1.0, this means that the
	// PRNG is uniformly distributed, for each pseudo-random number appears as often
	// as the others (binHeight ~ numBins).
	double avgBinHeight = (area / (binWidth * numBins) );
	printf("uniformly distributed: %.15e\n", avgBinHeight);


	r = prng.destroy(r);
	free(part);
	free(rands);

	r = NULL;
	part = NULL;
	rands = NULL;

	fclose(file);
	return;
}


/*
 * COMMENTS:
 * The preliminary frequency analysis shows that the pseudo-random numbers are uniformly
 * distributed. The Python code `frequency-analysis.py' can be used to plot the histogram
 * of the pseudo-random numbers generated by the PRNG.
 *
 */
